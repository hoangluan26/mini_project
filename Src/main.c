/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include <lcd.h>

#define PORT_SW_1		GPIOB
#define PIN_SW_1		7

#define PORT_SW_2		GPIOB
#define PIN_SW_2		3

#define PORT_SW_3		GPIOB
#define PIN_SW_3		4

#define PORT_SW_4		GPIOA
#define PIN_SW_4		1

#define PORT_LED_1		GPIOC
#define PIN_LED_1		6

#define PORT_LED_2		GPIOC	//TIM3_CH2
#define PIN_LED_2		7

#define PORT_LED_3		GPIOC	//TIM3_CH3
#define PIN_LED_3		8

#define PORT_LED_4		GPIOC	//TIM3_CH4
#define PIN_LED_4		9

#define PORT_BUZZER		GPIOC
#define PIN_BUZZER		10

#define PORT_POT1		GPIOC
#define PIN_POT1		2

uint8_t state_sw1 = 0, state_sw2 = 0, state_sw3 = 0, state_sw4 = 0; //init state of switch
uint8_t prestate_sw1 = 0, prestate_sw2 = 0, prestate_sw3 = 0, prestate_sw4 = 0; //init previous state of switch
uint8_t count_sw1 = 0, count_sw2 = 0, count_sw3 = 0, count_sw4 = 0; //init count of switch
uint16_t ADC_result;

/*
 * set pin mode
 * 0 -> input
 * 1 -> general purpose output
 * 2 -> alternative function
 * 3 -> Analog
 * */
void setMODE(GPIO_TypeDef *gpio, uint32_t pin, uint8_t type){
	gpio->MODER &= ~(3<<(pin*2)); //clear two bit set mode
	gpio->MODER |= (type<<(pin*2)); //set mode
}

/*
 * set pin mode
 * 0 -> no pull
 * 1 -> pull-up
 * 2 -> pull-down
 * 3 -> reverved
 * */
void setPULL(GPIO_TypeDef *gpio, uint32_t pin, uint8_t type){
	gpio->PUPDR &= ~(3<<(pin*2)); //clear two bit set mode
	gpio->PUPDR |= (type<<(pin*2)); //set mode
}

void setALT(GPIO_TypeDef *gpio, uint32_t pin, uint8_t AFx){
	if(pin < 8){
		gpio->AFR[0] &= ~(0xF << (pin*4)); //clear 4 bit config alternate fuction
		gpio->AFR[0] |= (AFx << (pin*4)); //set AFR
	}
	else {
		gpio->AFR[1] &= ~(0xF << ((pin-8)*4)); //clear 4 bit config alternate fuction
		gpio->AFR[1] |= (AFx << ((pin-8)*4)); //set AFR
	}
}

void initTIM3(void){
	RCC->APB1ENR |= (1<<1); //enable LED
	TIM3->PSC = 0; //prescale = 0 -> 16MHz
	TIM3->ARR = 1600-1; //frequency 1600/16x10^6 = 0.1ms
	TIM3->CNT = 0; //clear counter
	TIM3->CCMR1 |= (6<<12); //PWM mode 1 channel 2
	TIM3->CCMR2 |= (6<<4); //PWM mode 1 channel 3
	TIM3->CCMR2 |= (6<<12); //PWM mode 1 channel 4
	TIM3->CR1 = (1<<0);
}

void tim3_dutycycle(uint32_t freq, uint32_t duty_cycle, uint8_t channel){
	TIM3->ARR = ((65535/freq) - 1);
	switch(channel){
	case 1:
		TIM3->CCR1 = (duty_cycle*(TIM3->ARR+1))/100 - 1;
		break;
	case 2:
		TIM3->CCR2 = (duty_cycle*(TIM3->ARR+1))/100 - 1;
		break;
	case 3:
		TIM3->CCR3 = (duty_cycle*(TIM3->ARR+1))/100 - 1;
		break;
	case 4:
		TIM3->CCR4 = (duty_cycle*(TIM3->ARR+1))/100 - 1;
		break;
	default:
		break;
	}

}

void usart2_config(void){
	RCC->APB1ENR |= (1<<17);//en USART2
	RCC->AHB1ENR |= (1<<0);//enable Port A
	GPIOA->MODER |= (1<<5);//alt mode pin 2
	GPIOA->MODER |= (1<<7);//alt mode pin 3
	GPIOA->AFR[0] |= (7<<8); //AF7
	GPIOA->AFR[0] |= (7<<12); //AF7

	USART2->CR1 |= (1<<13); //enable usart
	//boundrate 9600
	USART2->BRR |= (3<<0); //fraction
	USART2->BRR |= (104<<4);//mantissa
	USART2->CR1 |= (3<<2);//enable TX RX
}

void writeDataUSART(char buffer[], uint16_t len){
	for(uint8_t i = 0; i < len; i++){
		USART2->DR = buffer[i];
		while((USART2->SR & (1<<6)) == 0){}
	}
}





void switchInit(void){
	RCC->AHB1ENR |= (1<<0); //enable GPIOA
	RCC->AHB1ENR |= (1<<1); //enable GPIOB

	setMODE(PORT_SW_1, PIN_SW_1, 0); //set mode switch 1 input
	setMODE(PORT_SW_2, PIN_SW_2, 0); //set mode switch 2 input
	setMODE(PORT_SW_3, PIN_SW_3, 0); //set mode switch 3 input
	setMODE(PORT_SW_4, PIN_SW_4, 0); //set mode switch 4 input

	setPULL(PORT_SW_1, PIN_SW_1, 2); //set mode switch 1 pull down
	setPULL(PORT_SW_2, PIN_SW_2, 2); //set mode switch 2 pull down
	setPULL(PORT_SW_3, PIN_SW_3, 2); //set mode switch 3 pull down
	setPULL(PORT_SW_4, PIN_SW_4, 2); //set mode switch 4 pull down


}

void LEDInit(void){
	RCC->AHB1ENR |= (1<<1); //enable GPIOB
	RCC->AHB1ENR |= (1<<2); //enable GPIOC
	setMODE(PORT_LED_1, PIN_LED_1, 1); //set mode LED 1 output


	setMODE(PORT_LED_2, PIN_LED_2, 2); //set mode LED 2 alternative
	setMODE(PORT_LED_3, PIN_LED_3, 2); //set mode LED 3 alternative
	setMODE(PORT_LED_4, PIN_LED_4, 2); //set mode LED 4 alternative

	setALT(PORT_LED_2, PIN_LED_2, 2);	//set LED 2 AF2 -> TIM3 CH2
	setALT(PORT_LED_3, PIN_LED_3, 2);	//set LED 3 AF2 -> TIM3 CH3
	setALT(PORT_LED_4, PIN_LED_4, 2);	//set LED 4 AF2 -> TIM3 CH4

}

void buzzerInit(void){
	RCC->AHB1ENR |= (1<<2); //enable GPIOC
	setMODE(PORT_BUZZER, PIN_BUZZER, 1);//set mode BUZZER output
}

void delay_ms(uint32_t t){
	for(uint32_t i = 0; i < t; i++)
		for(uint32_t j = 0; j < 16000; j++);
}

void handleSW1(void){
	if(count_sw1) {
		lprint(0x80, "Live Epression");
		PORT_LED_1->ODR |= (1<<PIN_LED_1); //turn on LED 1 if count == 1
		char buffer[] = {"Ignition Status ON\r\n"};
		writeDataUSART(buffer, sizeof(buffer)/sizeof(char));
	}
	else {
		lprint(0x80, "              ");
		lprint(0xc0, "    ");
		PORT_LED_1->ODR &= ~(1<<PIN_LED_1);// turn of LED 1 if count == 0
		char buffer[] = {"Ignition Status OFF\r\n"};
		writeDataUSART(buffer, sizeof(buffer)/sizeof(char));
		//reset state all switch
		count_sw2 = 0;
		count_sw3 = 0;
		count_sw4 = 0;
	}
}

void handleSW2(void){
	if(count_sw1){
		if(count_sw2 == 1){
			char buffer[] = {"Low Beam\r\n"};
			writeDataUSART(buffer, sizeof(buffer)/sizeof(char));
			TIM3->CCER |= (3<<4); //enable captrue/compare 2 output
			tim3_dutycycle(1, 90, 2); //Low Beam LED 2 -> 10% dutycycle
		}
		else if(count_sw2 == 2){
			char buffer[] = {"High Beam\r\n"};
			writeDataUSART(buffer, sizeof(buffer)/sizeof(char));
			TIM3->CCER |= (3<<4); //enable captrue/compare 2 output
			tim3_dutycycle(1, 10, 2); //High Beam LED 2 -> 90% dutycycle
		}
		else if(count_sw2 == 3){
			if(!count_sw3 && !count_sw4){
				char buffer[] = {"Parking Light ON\r\n"};
				writeDataUSART(buffer, sizeof(buffer)/sizeof(char));
				TIM3->CCER |= (3<<8); //enable captrue/compare 3 output
				tim3_dutycycle(1, 50, 3); //blink LED 3
				TIM3->CCER |= (3<<12); //enable captrue/compare 4 output
				tim3_dutycycle(1, 50, 4);//blink LED 4
				PORT_BUZZER->ODR |= (1<<PIN_BUZZER); //turn on buzzer
			}
		}
		else {
			char buffer[] = {"Parking Light OFF\r\n"};
			writeDataUSART(buffer, sizeof(buffer)/sizeof(char));
			tim3_dutycycle(1, 99, 2);
			tim3_dutycycle(1, 99, 3);
			tim3_dutycycle(1, 99, 4);
			TIM3->CCER &= ~(3<<4); //disable captrue/compare 2 output
			TIM3->CCER &= ~(3<<8); //disable captrue/compare 3 output
			TIM3->CCER &= ~(3<<12); //disable captrue/compare 4 output
			PORT_BUZZER->ODR &= ~(1<<PIN_BUZZER); //turn off buzzer
		}
	}
}

void handleSW3(void){
	if(count_sw1){
		if(count_sw3){
			if(!count_sw4){
				char buffer[] = {"Right Indication ON\r\n"};
				writeDataUSART(buffer, sizeof(buffer)/sizeof(char));
				TIM3->CCER |= (3<<8); //enable captrue/compare 3 output
				tim3_dutycycle(1, 50, 3); //blink LED 3
				PORT_BUZZER->ODR |= (1<<PIN_BUZZER); //turn on buzzer
			}
			else{
				char buffer1[] = {"Right Indication OFF\r\n"};
				writeDataUSART(buffer1, sizeof(buffer1)/sizeof(char));
				char buffer2[] = {"Left Indication OFF\r\n"};
				writeDataUSART(buffer2, sizeof(buffer2)/sizeof(char));
				count_sw3 = 0;
				count_sw4 = 0;
				tim3_dutycycle(1, 99, 3);
				tim3_dutycycle(1, 99, 4);
				TIM3->CCER &= ~(3<<8); //disable captrue/compare 3 output
				TIM3->CCER &= ~(3<<12); //disable captrue/compare 4 output
				PORT_BUZZER->ODR &= ~(1<<PIN_BUZZER); //turn off buzzer
			}
		}
		else {
			char buffer[] = {"Right Indication OFF\r\n"};
			writeDataUSART(buffer, sizeof(buffer)/sizeof(char));
			tim3_dutycycle(1, 99, 3);
			TIM3->CCER &= ~(3<<8); //disable captrue/compare 3 output
			PORT_BUZZER->ODR &= ~(1<<PIN_BUZZER); //turn off buzzer
		}
	}
}

void handleSW4(void){
	if(count_sw1){
		if(count_sw4){
			if(!count_sw3){
				char buffer[] = {"Left Indication ON\r\n"};
				writeDataUSART(buffer, sizeof(buffer)/sizeof(char));
				TIM3->CCER |= (3<<12); //enable captrue/compare 4 output
				tim3_dutycycle(1, 50, 4);//blink LED 4
				PORT_BUZZER->ODR |= (1<<PIN_BUZZER); //turn on buzzer
			}
			else{
				count_sw3 = 0;
				count_sw4 = 0;
				tim3_dutycycle(1, 99, 3);
				tim3_dutycycle(1, 99, 4);
				TIM3->CCER &= ~(3<<8); //disable captrue/compare 3 output
				TIM3->CCER &= ~(3<<12); //disable captrue/compare 4 output
				PORT_BUZZER->ODR &= ~(1<<PIN_BUZZER); //turn off buzzer
			}
		}
		else {
			char buffer[] = {"Left Indication OFF\r\n"};
			writeDataUSART(buffer, sizeof(buffer)/sizeof(char));
			tim3_dutycycle(1, 99, 4);
			TIM3->CCER &= ~(3<<12); //disable captrue/compare 4 output
			PORT_BUZZER->ODR &= ~(1<<PIN_BUZZER); //turn off buzzer
		}
	}
}

int main(void)
{
	switchInit();
	LEDInit();
	buzzerInit();
	initTIM3();
	usart2_config();
	adc_init();
	LcdInit();


	while(1){
		state_sw1 = PORT_SW_1->IDR & (1<<PIN_SW_1); //read input switch 1
		state_sw2 = PORT_SW_2->IDR & (1<<PIN_SW_2); //read input switch 2
		state_sw3 = PORT_SW_3->IDR & (1<<PIN_SW_3); //read input switch 3
		state_sw4 = PORT_SW_4->IDR & (1<<PIN_SW_4); //read input switch 4
		//check if switch change state
		if((state_sw1 != prestate_sw1) || (state_sw2 != prestate_sw2) || (state_sw3 != prestate_sw3) || (state_sw4!=prestate_sw4)){
			delay_ms(10); //prevent decounce
			state_sw1 = PORT_SW_1->IDR & (1<<PIN_SW_1); //read input switch 1
			state_sw2 = PORT_SW_2->IDR & (1<<PIN_SW_2); //read input switch 2
			state_sw3 = PORT_SW_3->IDR & (1<<PIN_SW_3); //read input switch 3
			state_sw4 = PORT_SW_4->IDR & (1<<PIN_SW_4); //read input switch 4
			//check if switch change state again to avoid debounce
			if((state_sw1 != prestate_sw1) || (state_sw2 != prestate_sw2) || (state_sw3 != prestate_sw3) || (state_sw4!=prestate_sw4)){
				//check if state switch change from LOW to HIGH
				if(state_sw1){
					count_sw1 += 1;
					count_sw1 = count_sw1 % 2; //count value only 0 and 1 present 1st press and 2nd press
					handleSW1();
				}
				if(state_sw2){
					count_sw2 += 1;
					count_sw2 = count_sw2 % 4;//count value 0,1,2,3 for represents four presses
					handleSW2();
				}
				if(state_sw3){
					count_sw3 += 1;
					count_sw3 = count_sw3 % 2;//count value only 0 and 1 present 1st press and 2nd press
					handleSW3();
				}
				if(state_sw4){
					count_sw4 += 1;
					count_sw4 = count_sw4 % 2;//count value only 0 and 1 present 1st press and 2nd press
					handleSW4();
				}
				//update previous state of switch
				prestate_sw1 = state_sw1;
				prestate_sw2 = state_sw2;
				prestate_sw3 = state_sw3;
				prestate_sw4 = state_sw4;
			}
		}

		if(count_sw1){
			ADC_result = adc_read();
			aprint(ADC_result, 0xc0);
//			for(uint32_t j=0;j<20000;j++);
		}
	}
}
